package archontophoenix.pretty.test

import archontophoenix.pretty._
import org.scalacheck._

/**
 * Random identifiers that look more or less pronounceable to English
 * speakers.
 */
object Identifiers {
  import Gen._
  val oneChar =
    oneOf(
      "a","b","c","f","g","i","j","m","n","p","q","r","s","t","x","y","z")
  val voicelessPlosive = oneOf("p","t","c")
  val voicedPlosive = oneOf("b","d","g")
  val plosive = oneOf(voicelessPlosive,voicedPlosive)
  val approximant = oneOf("l","r")
  val nasal = oneOf("m","n")
  val voicelessFricative = oneOf("f","th","s","sh")
  val voicedFricative = oneOf("v","z")
  val fricative = oneOf(voicelessFricative,voicedFricative)
  val ess = value("s")
  val aitch = value("h")
  val initialConsonant =
    frequency(
      (20,plosive),
      (6,fricative),
      (5,concat(plosive,approximant)),
      (4,oneOf(approximant,nasal)),
      (3,concat(ess,voicelessPlosive)),
      (2,concat(ess,voicelessPlosive,approximant)),
      (1,aitch))
  val shortVowel = oneOf("a","e","i","o","u")
  val longVowel = oneOf("ai","au","ea","ee","oa","oi","ou")
  val ee = value("e")
  val monosyllableFinal =
    frequency(
      (10,longVowel),
      (10,concat(shortVowel,plosive)),
      (10,concat(longVowel,oneOf(approximant,nasal))),
      (8,concat(shortVowel,oneOf(approximant,nasal,value("ng")))),
      (7,concat(shortVowel,voicelessFricative)),
      (7,concat(shortVowel,plosive,ee)),
      (6,concat(shortVowel,oneOf(approximant,nasal),ee)),
      (6,concat(shortVowel,voicelessFricative,ee)))
  val monosyllable = concat(initialConsonant,monosyllableFinal)
  val bisyllable = concat(shortVowel,initialConsonant,longVowel)
  val camel =
    oneOf(
      concat(monosyllable,cap(monosyllable)),
      concat(monosyllable,cap(bisyllable)),
      concat(bisyllable,cap(monosyllable)))
  val id =
    frequency(
      (10,oneChar),
      (10,monosyllable),
      (4,bisyllable),
      (2,camel))
  def concat (ss: Gen[String]*): Gen[String] = {
    def plus (s1: Option[String], s2: Option[String]): Option[String] =
      if (s1.isEmpty || s2.isEmpty) None else Some(s1.get + s2.get)
    val h = ss.head
    if (ss.size <= 1) h else h.combine(concat(ss.tail: _*))(plus _)
  }
  def cap (g: Gen[String]): Gen[String] = g.map(_.capitalize)
}

/**
 * Root of statement/expression hierarchy that can be generated by
 * ScalaCheck.
 */
trait Statement extends PrettyLike

object Statement {
  def frequenciesWithoutBlock (maxDepth: Int) =
    Seq(
      (10,Expression.genWithoutBlock(maxDepth)),
      (3,Assignment.gen(maxDepth)),
      (3,If.gen(maxDepth)),
      (1,While.gen(maxDepth)),
      (1,Do.gen(maxDepth)),
      (1,For.gen(false,maxDepth)))
  def frequenciesWithBlock (maxDepth: Int) =
    frequenciesWithoutBlock(maxDepth) :+ (1,Block.gen(maxDepth))
  def gen (maxDepth: Int): Gen[Statement] =
    if (maxDepth <= 1) Id.gen
    else Gen.frequency(frequenciesWithBlock(maxDepth): _*)
  def genWithoutBlock (maxDepth: Int): Gen[Statement] =
    if (maxDepth <= 1) Id.gen
    else Gen.frequency(frequenciesWithoutBlock(maxDepth): _*)
}

trait Expression extends Statement

object Expression {
  def frequenciesWithoutBlock (maxDepth: Int) =
    Seq(
      (10,Id.gen),
      (7,Binary.gen(maxDepth)),
      (5,Invocation.gen(maxDepth)),
      (4,Field.gen(maxDepth)),
      (1,For.gen(true,maxDepth)),
      (1,Unary.gen(maxDepth)),
      (1,BlockInvocation.gen(maxDepth)))
  def frequenciesWithBlock (maxDepth: Int) =
    frequenciesWithoutBlock(maxDepth) :+ (1,Block.gen(maxDepth))
  def gen (maxDepth: Int): Gen[Expression] =
    if (maxDepth <= 1) Id.gen
    else Gen.frequency(frequenciesWithBlock(maxDepth): _*)
  def genWithoutBlock (maxDepth: Int): Gen[Expression] =
    if (maxDepth <= 1) Id.gen
    else Gen.frequency(frequenciesWithoutBlock(maxDepth): _*)
}

case class Id (id: String) extends Expression {
  def pretty: Prettify = Show(id)
  override def toString: String = "Id(\"" + id + "\")"
}

object Id {
  def gen: Gen[Id] =
    for {
      id <- Identifiers.id
    } yield Id(id)
}

case class Invocation (receiver: Expression, args: Expression*)
    extends Expression {
  def pretty: Prettify =
    Indent(
      Invocation.prettyReceiver(receiver),"(",LeftBreak,
      Prettify(
        args,",",
        (x: Expression, sep: Option[Prettify]) =>
          Group(
            LeftBreak,
            Group(
              Show(x),
              sep match {
                case Some(s) => Concat(s,LeftBreak)
                case None => Empty
              }))),
      ")")
}

object Invocation {
  def gen (maxDepth: Int): Gen[Invocation] =
    for {
      rcvr <- Expression.gen(maxDepth - 1)
      args <- {
          import Gen._
          val exp = Expression.gen(maxDepth - 1)
          frequency(
            (100,listOfN(1,exp)),
            (50,listOfN(2,exp)),
            (25,listOfN(3,exp)),
            (12,listOfN(4,exp)),
            (6,listOfN(5,exp)),
            (3,listOfN(6,exp)),
            (1,listOfN(7,exp)))
        }
    } yield Invocation(rcvr,args: _*)
  def prettyReceiver (r: Expression): Prettify =
    r match {
      case Unary(_,_) => Concat("(",Show(r),")")
      case Binary(_,_,_) => Concat("(",Show(r),")")
      case bl: Block => bl.exdent(2)
      case _ => Show(r)
    }
}

case class BlockInvocation (receiver: Expression, arg: Block)
    extends Expression {
  def pretty: Prettify =
    Indent(Invocation.prettyReceiver(receiver)," ",arg.exdent(1))
}

object BlockInvocation {
  def gen (maxDepth: Int): Gen[BlockInvocation] =
    for {
      rcvr <- Expression.gen(maxDepth - 1)
      arg <- Block.gen(maxDepth - 1)
    } yield BlockInvocation(rcvr,arg)
}

case class UnaryOp (opName: String) extends PrettyLike {
  def pretty: Prettify = Show(opName)
  override def toString: String = "UnaryOp(\"" + opName + "\")"
}

object UnaryOp {
  val opNames = Set("+","-","!","~")
  def gen: Gen[UnaryOp] = Gen.oneOf(opNames.toSeq).map(UnaryOp(_))
}

case class Unary (op: UnaryOp, arg: Expression) extends Expression {
  def pretty: Prettify =
    arg match {
      case b: Binary => Indent(Show(op)," (",LeftBreak,Show(b),")")
      case u: Unary => Concat(Show(op)," ",Show(u))
      case bl: Block => Concat(Show(op)," ",bl.exdent(2))
      case _ => Indent(Show(op),LeftBreak(" "),Show(arg))
    }
}

object Unary {
  def gen (maxDepth: Int): Gen[Unary] =
    for {
      op <- UnaryOp.gen
      arg <- Expression.gen(maxDepth - 1)
    } yield Unary(op,arg)
}

case class BinaryOp (opName: String) extends PrettyLike {
  def pretty: Prettify = Show(opName)
  def precedence = BinaryOp.precedences(opName)
  override def toString: String = "BinaryOp(\"" + opName + "\")"
}

object BinaryOp {
  val precedences: Map[String,Int] =
    {
      val byPrecedence: List[Set[String]] =
        List(
          Set("||"),
          Set("&&"),
          Set("<",">","<=",">="),
          Set("+","-"),
          Set("*","/","%"))
      Map.empty[String,Int] ++
        byPrecedence.zipWithIndex.map(
            (si: (Set[String],Int)) => si._1.zip(Stream.continually(si._2))).
          flatten
    }
  val ops = precedences.keySet
  def gen: Gen[BinaryOp] = Gen.oneOf(ops.toSeq).map(BinaryOp(_))
}

case class Binary (left: Expression, op: BinaryOp, right: Expression)
    extends Expression {
  def prettyOnLeft: Prettify = {
    def maybeParen (x: Expression) =
      x match {
        case b @ Binary(_,oo,_) if (op.precedence >= oo.precedence) =>
          Concat("(",Show(b),")")
        case bl: Block =>
          bl.exdent(2)
        case _ =>
          Show(x)
      }
    left match {
      case b @ Binary(_,oo,_) if op.precedence == oo.precedence =>
        Concat(b.prettyOnLeft," ",Show(op),WeakBreak(" "),maybeParen(right))
      case _ =>
        Concat(
          Group(maybeParen(left)," ",Show(op),LeftBreak(" ")),
          Group(LeftBreak,maybeParen(right)))
    }
  }
  def pretty: Prettify = Indent(prettyOnLeft)
}

object Binary {
  def gen (maxDepth: Int): Gen[Binary] =
    for {
      left <- Expression.gen(maxDepth - 1)
      op <- BinaryOp.gen
      right <- Expression.gen(maxDepth - 1)
    } yield Binary(left,op,right)
}

case class Field (base: Expression, field: Id) extends Expression {
  def pretty: Prettify = {
    def prettyBase (base: Expression): Prettify =
      base match {
        case Field(b2,f) =>
          Concat(prettyBase(b2),Show(f),".",WeakBreak)
        case Unary(_,_) =>
          Group("(",Show(base),").",LeftBreak)
        case Binary(_,_,_) =>
          Group("(",Show(base),").",LeftBreak)
        case bl: Block =>
          Group(bl.exdent(2),".",WeakBreak)
        case _ =>
          Group(Show(base),".",LeftBreak)
      }
    Indent(prettyBase(base),Show(field))
  }
}

object Field {
  def gen (maxDepth: Int): Gen[Field] =
    for {
      base <- Expression.gen(maxDepth - 1)
      field <- Id.gen
    } yield Field(base,field)
}

case class Assignment (id: Id, expr: Expression) extends Statement {
  def pretty: Prettify = Indent(Show(id)," =",LeftBreak(" "),Show(expr))
}

object Assignment {
  def gen (maxDepth: Int): Gen[Assignment] =
    for {
      id <- Id.gen
      expr <- Expression.gen(maxDepth - 1)
    } yield Assignment(id,expr)
}

case class Block (statements: Statement*) extends Expression {
  def purdy (braceIndent: Indenter, innerIndent: Int): Prettify =
    Group(
      braceIndent,"{",
      Group(
        Block.multipleIndent(innerIndent),
        Prettify(statements,(st: Statement) => Group(HardBreak,Show(st)))),
      HardBreak,"}")
  def pretty: Prettify = purdy(NoIndent,1)
  def exdent (innerIndent: Int): Prettify = purdy(Block.unindenter,innerIndent)
}

object Block {
  val unindenter =
    new Indenter {
      def newMargin (margin: Int, column: Int, limits: Limits): Int =
        (margin - limits.defaultIndent) max 0
      override def toString: String = "Unindent"
    }
  def multipleIndent (timesDefault: Int) =
    new Indenter {
      def newMargin (margin: Int, column: Int, limits: Limits): Int =
        margin + timesDefault * limits.defaultIndent
      override def toString: String = "Indent*" + timesDefault
    }
  def gen (maxDepth: Int): Gen[Block] = {
    import Gen._
    val stmt = Statement.genWithoutBlock(maxDepth - 1)
    for {
      stmts <-
        frequency(
          (100,listOfN(2,stmt)),
          (50,listOfN(3,stmt)),
          (25,listOfN(4,stmt)),
          (12,listOfN(5,stmt)),
          (6,listOfN(6,stmt)),
          (3,listOfN(7,stmt)),
          (1,listOfN(8,stmt)))
    } yield Block(stmts: _*)
  }
}

abstract class IfOrWhile (keyword: String, cond: Expression, stmt: Statement)
    extends Statement {
  def pretty: Prettify =
    Indent(
      keyword," (",Indent(Show(cond)),")",
      stmt match {
        case bl: Block => Concat(" ",bl.exdent(1))
        case _ => Concat(LeftBreak(" "),Show(stmt))
      })
}

case class If (cond: Expression, stmt: Statement)
  extends IfOrWhile("if",cond,stmt)

object If {
  def gen (maxDepth: Int): Gen[If] =
    for {
      cond <- Expression.gen(maxDepth - 1)
      stmt <- Statement.gen(maxDepth - 1)
    } yield If(cond,stmt)
}

case class While (cond: Expression, stmt: Statement)
  extends IfOrWhile("while",cond,stmt)

object While {
  def gen (maxDepth: Int): Gen[While] =
    for {
      cond <- Expression.gen(maxDepth - 1)
      stmt <- Statement.gen(maxDepth - 1)
    } yield While(cond,stmt)
}

case class Do (stmt: Statement, cond: Expression) extends Statement {
  def pretty: Prettify =
    Group(
      "do",
      stmt match {
        case bl: Block =>
          Indent(Concat(" ",bl.exdent(1)," "))
        case _ =>
          Concat(Indented(LeftBreak(" ")),Show(stmt),LeftBreak(" "))
      },
      "while (",Indent(Show(cond)),")")
}

object Do {
  def gen (maxDepth: Int): Gen[Do] =
    for {
      stmt <- Statement.gen(maxDepth - 1)
      cond <- Expression.gen(maxDepth - 1)
    } yield Do(stmt,cond)
}

trait GeneratorOrGuard extends PrettyLike

object GeneratorOrGuard {
  def gen (maxDepth: Int): Gen[GeneratorOrGuard] =
    Gen.frequency(
      (3,Generator.gen(maxDepth)),
      (2,Guard.gen(maxDepth)))
}

case class Generator (id: Id, expr: Expression) extends GeneratorOrGuard {
  def pretty: Prettify = Indent(Show(id)," <-",LeftBreak(" "),Show(expr))
}

object Generator {
  def gen (maxDepth: Int): Gen[Generator] =
    for {
      id <- Id.gen
      expr <- Expression.gen(maxDepth - 1)
    } yield Generator(id,expr)
}

case class Guard (cond: Expression) extends GeneratorOrGuard {
  def pretty: Prettify = Indent("if ",Show(cond))
}

object Guard {
  def gen (maxDepth: Int): Gen[Guard] =
    for {
      cond <- Expression.gen(maxDepth - 1)
    } yield Guard(cond)
}

case class For (
      withParens: Boolean, g0: Generator, gs: Seq[GeneratorOrGuard],
      withYield: Boolean, expr: Expression)
    extends Expression {
  def pretty: Prettify = {
    val (open,close,sep,yieldBreak) =
      if (withParens)
        (Concat("(",LeftBreak),Show(")"),Concat(";",LeftBreak(" ")),
          LeftBreak(" "))
      else
        (Concat("{",HardBreak),Concat(HardBreak,"}"),HardBreak,HardBreak)
    Group(
      "for ",Indent(Indent(open,Prettify(g0 +: gs,sep))),close,
      if (withYield) Show(" yield") else Empty,
      Indent(
        expr match {
          case bl: Block => Concat(" ",bl.exdent(1))
          case _ => Concat(yieldBreak,Show(expr))
        }))
  }
}

object For {
  def gen (withYield: Boolean, maxDepth: Int): Gen[For] =
    for {
      withParens <- Gen.oneOf(true,false)
      g0 <- Generator.gen(maxDepth - 1)
      val gg = GeneratorOrGuard.gen(maxDepth - 1)
      gs <- {
        import Gen._
        frequency(
          (100,listOfN(0,gg)),
          (50,listOfN(1,gg)),
          (25,listOfN(2,gg)),
          (12,listOfN(3,gg)),
          (6,listOfN(4,gg)),
          (3,listOfN(5,gg)),
          (1,listOfN(6,gg)))
      }
      expr <- Expression.gen(maxDepth - 1)
    } yield For(withParens,g0,gs,withYield,expr)
}

/**
 * ScalaCheck test that generates some random expressions and prettyprints them,
 * then runs the ScalaTest tests that were developed from such randomly
 * generated expressions.
 */
object CheckPretty {
  def main (args: Array[String]) {
    val suite = new CheckPrettySuite
    for (i <- 1 to 100)
      suite.display(Expression.gen(7).sample.get,None)
    CheckPrettySuite.main(args)
  }
}

import org.scalatest.Suite

/** ScalaTest test that runs ScalaCheck tests. */
object CheckPrettySuite {
  def main (args: Array[String]) {
    (new CheckPrettySuite).testPretty
  }
}

class CheckPrettySuite extends Suite {
  def display (p: Statement, expectedAtWidth20: Option[String]) {
    println("\n" + "=" * 79)
    println(p)
    println
    val pp = p.pretty
    println(pp.debugString)
    println
    println(pp.prettified)
    println
    val tt = pp.tokens
    println(tt.takeWhile(_ != End).mkString(" "))
    println
    var n = Token.normalize(tt)
    while (n.token != End) {
      print(n.toString + " ")
      n = n.next
    }
    println
    println
    for (wid <- List(20,80)) {
      println("." * wid)
      val result = pp.render(Limits(wid)).toString
      println(result)
      if (wid == 20 && ! expectedAtWidth20.isEmpty) {
        def dropRightWhite (s: String): String =
          if (! s.isEmpty && s.last.isWhitespace) dropRightWhite(s.init)
          else s
        def dropRightWhiteAll (s: String) =
          s.split('\n').map(dropRightWhite(_)).foldLeft("")(_ + _)
        expect(dropRightWhiteAll(expectedAtWidth20.get)) {
          dropRightWhiteAll(result)
        }
      }
      println("." * wid)
    }
    println
  }
  def testPretty {
    display(
      Binary(
        Invocation(Id("taun"),Id("ecoa")),BinaryOp("+"),
        Field(Field(Id("bore"),Id("zishe")),Id("spreme"))),
Some("""taun(ecoa) +
  bore.zishe.spreme"""))
    display(
      Field(
        Binary(Id("ecai"),BinaryOp("<"),Field(Id("scoin"),Id("thom"))),
        Id("deb")),
Some("""(ecai < scoin.thom).
  deb"""))
    display(
      Invocation(
        Unary(
            UnaryOp("~"),
            Field(
              Binary(
                Field(Id("i"),Id("tac")),
                BinaryOp("*"),
                Id("hesh")),
              Id("vome"))),
        Binary(
          Binary(Id("c"),BinaryOp(">="),Id("droul")),
          BinaryOp(">="),
          Id("n"))),
Some("""(~ (i.tac * hesh).
      vome)(
  c >= droul >= n)"""))
    display(
      Field(
        Binary(
          Field(
            Unary(UnaryOp("-"),Id("shoi")),
            Id("baun")),
          BinaryOp("||"),
          Binary(
            Id("b"),
            BinaryOp("||"),
            Field(Id("gut"),Id("z")))),
      Id("ceb")),
Some("""((- shoi).baun ||
    (b || gut.z)).
  ceb"""))
    display(
      Field(
        Field(
          Block(
            Binary(
              Id("i"),
              BinaryOp("<"),
              Invocation(
                Id("scrode"),
                Field(Id("azea"),Id("a")),Id("apau"),Id("drumIscea"))),
            Id("j"),
            Assignment(Id("i"),Field(Unary(UnaryOp("~"),Id("g")),Id("vos")))),
          Id("goi")),
        Id("shug")),
Some("""{
    i <
      scrode(
        azea.a,apau,
        drumIscea)
    j
    i = (~ g).vos
}.goi.shug"""))
    display(
      Invocation(Block(Id("abcdefghijklm")),Id("nopqrstuvwxyz")),
Some("""{
    abcdefghijklm
}(nopqrstuvwxyz)"""))
    display(
      Binary(
        Field(
          Field(
            Invocation(
              Field(Binary(Id("isoa"),BinaryOp("/"),Id("zog")),Id("ascrea")),
              Id("j")),
            Id("gebe")),
          Id("stom")),
        BinaryOp("*"),
        Binary(
          Invocation(Id("zoi"),Id("q")),
          BinaryOp("<"),
          Id("ruf"))),
Some("""(isoa / zog).ascrea(
      j).
    gebe.stom *
  (zoi(q) < ruf)"""))
    display(
      Field(
        Field(
          Field(
            Id("alphabetagamma"),
            Id("deltaepsilon")),
          Id("zetaetatheta")),
        Id("iotakappalambda")),
Some("""alphabetagamma.
  deltaepsilon.
  zetaetatheta.
  iotakappalambda"""))
    display(
      Invocation(
        Id("alphaBeta"),Id("gammaDelta"),Id("epsilonZeta"),Id("etaTheta"),
        Id("iotaKappa"),Id("LambdaMu"),Id("nuXi"),Id("omicronPi"),
        Id("rhoSigma"),Id("TauUpsilon"),Id("phiChi"),Id("psiOmega")),
Some("""alphaBeta(
  gammaDelta,
  epsilonZeta,
  etaTheta,
  iotaKappa,
  LambdaMu,nuXi,
  omicronPi,
  rhoSigma,
  TauUpsilon,phiChi,
  psiOmega)"""))
    display(
      Field(
        Field(Field(Field(Id("t"),Id("isploi")),Id("z")),Id("scrideAdai")),
        Id("j")),
Some("""t.isploi.z.
  scrideAdai.j"""))
    display(
      Binary(Block(Id("pun"),Id("bou")),BinaryOp("%"),Id("aloa")),
Some("""{
    pun
    bou
} %
  aloa"""))
    display(
      Binary(
        Id("t"),
        BinaryOp(">="),
        Binary(Field(Id("peal"),Id("gaul")),BinaryOp("&&"),Id("veem"))),
Some("""t >=
  (peal.gaul &&
    veem)"""))
    display(
      Field(
        Invocation(
          Binary(
            Binary(
              Id("gufe"),
              BinaryOp("-"),
              Invocation(
                Invocation(Id("t"),Id("q")),
                Id("c"))),
            BinaryOp("%"),
            Binary(
              Invocation(Id("r"),Id("z")),
              BinaryOp("/"),
              Binary(
                Binary(Id("g"),BinaryOp("-"),Id("fac")),
                BinaryOp("%"),
                Binary(Id("g"),BinaryOp(">"),Id("z"))))),
          Id("b"),Id("cou"),
          Binary(
            Binary(
              Field(Field(Id("scire"),Id("breshe")),Id("cife")),
              BinaryOp("-"),
              Id("bir")),
            BinaryOp(">"),
            Id("droin"))),
        Id("gude")),
Some("""((gufe - t(q)(c)) %
      (r(z) / 
        ((g - fac) %
          (g > 
            z))))(
    b,cou,
    scire.breshe.
          cife -
        bir >
      droin).
  gude"""))
    display(
      Binary(
        Field(
          Binary(
            Invocation(
              Field(Id("dute"),Id("dloneScled")),
              Id("tlid"),Id("splis")),
            BinaryOp("<="),
            Id("t")),
          Id("y")),
        BinaryOp("+"),
        Id("vem")),
Some("""(dute.dloneScled(
        tlid,
        splis) <=
      t).
    y +
  vem"""))
    display(
      Binary(
        Id("alphaBeta"),
        BinaryOp("+"),
        Binary(
          Id("gammaDelta"),
          BinaryOp("+"),
          Binary(
            Id("epsilonZeta"),
            BinaryOp("+"),
            Binary(
              Id("etaTheta"),
              BinaryOp("+"),
              Binary(
                Id("iotaKappa"),
                BinaryOp("+"),
                Binary(
                  Id("lambdaMu"),
                  BinaryOp("+"),
                  Id("nuXi"))))))),
Some("""alphaBeta +
  (gammaDelta +
    (epsilonZeta +
      (etaTheta +
        (iotaKappa +
          (lambdaMu +
            nuXi)))))"""))
    display(
      Binary(
        Binary(
          Binary(
            Binary(
              Binary(
                Binary(
                  Id("alphaBeta"),
                  BinaryOp("+"),
                  Id("gammaDelta")),
                BinaryOp("+"),
                Id("epsilonZeta")),
              BinaryOp("+"),
              Id("etaTheta")),
            BinaryOp("+"),
            Id("iotaKappa")),
          BinaryOp("+"),
          Id("lambdaMu")),
        BinaryOp("+"),
        Id("nuXi")),
Some("""alphaBeta +
  gammaDelta +
  epsilonZeta +
  etaTheta +
  iotaKappa +
  lambdaMu + nuXi"""))
    display(
      BlockInvocation(
        Id("hello"),
        Block(Id("goodbye"))),
Some("""hello {
  goodbye
}"""))
    display(
      Block(
        Id("what"),
        Id("is"),
        Id("up")),
Some("""{
  what
  is
  up
}"""))
    display(
      Field(
        Field(
          Invocation(
            Id("coul"),
            BlockInvocation(
              Binary(Id("s"),BinaryOp("<"),Id("c")),
              Block(
                Binary(Id("bise"),BinaryOp("-"),Id("atoi")),
                Field(Id("otea"),Id("poul")),
                Assignment(Id("b"),Id("athou")),
                Binary(Id("vobe"),BinaryOp("<"),Id("plash")))),
            Id("zer"),
            Binary(
              Binary(Field(Id("y"),Id("q")),BinaryOp("||"),Id("dear")),
              BinaryOp("*"),
              Id("b")),
            Id("ucrou")),
          Id("q")),
        Id("f")),
Some("""coul(
    (s < c) {
      bise - atoi
      otea.poul
      b = athou
      vobe < plash
    },
    zer,
    (y.q || dear) *
      b,
    ucrou).
  q.f"""))
    display(
      Invocation(
        Id("foo"),
        Id("a"),
        Block(Id("b"),Id("c")),
        Id("d")),
Some("""foo(
  a,
  {
    b
    c
  },
  d)"""))
    display(
      If(Id("cond"),Block(Id("foo"),Id("bar"))),
Some("""if (cond) {
  foo
  bar
}"""))
    display(
      Do(Id("x"),Id("y")),
Some("""do x while (y)"""))
    display(
      Do(Id("xxxxxxxxxx"),Id("yyyyyyyyyy")),
Some("""do
  xxxxxxxxxx
while (yyyyyyyyyy)"""))
    display(
      For(
        false,Generator(Id("a"),Id("b")),List(Generator(Id("c"),Id("d"))),
        true,Id("blargle")),
Some("""for {
    a <- b
    c <- d
} yield
  blargle"""))
    display(
      For(
        true,Generator(Id("a"),Id("b")),List(Generator(Id("c"),Id("d"))),
        true,Id("blargle")),
Some("""for (
    a <- b;
    c <- d) yield
  blargle"""))
  }
}
